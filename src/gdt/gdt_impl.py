# -*- coding: utf-8 -*-
"""GDT implementation for handling gene nomenclature data.

This module provides classes and functions to read, write, and manipulate gene
nomenclature data in GDT (Gene Description Table) format. It includes the
`GeneDict` class for storing gene information, as well as utility functions for
reading GDT files, sorting gene entries, and creating stripped GDT files.

"""

import re
from collections import UserDict, defaultdict
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Callable, Iterable, Optional, TypeVar, Union

from . import logger_setup


@dataclass(slots=True)
class _Gene:
    label: str
    c: Optional[str]


@dataclass(slots=True)
class DbxrefGeneID(_Gene):
    """A gene with a Dbxref GeneID."""

    an_source: str
    GeneID: int


@dataclass(slots=True)
class GeneGeneric(_Gene):
    """A generic gene ID with multiple AN sources."""

    an_sources: list[str] = field(default_factory=list)


@dataclass(slots=True)
class GeneDescription(_Gene):
    """A description of a gene."""

    source: str


@dataclass(slots=True)
class _GeneDictInfo:
    labels: int = 0
    total_entries: int = 0
    gene_descriptions: int = 0
    gene_generics: int = 0
    dbxref_GeneIDs: int = 0


GeneUnion = Union[GeneDescription, GeneGeneric, DbxrefGeneID]


class GeneDict(UserDict[str, GeneUnion]):
    """A dictionary to store gene nomeclature information with additional metadata.

    Attributes:
        version (str): Version of the GDT format.
        header (list[str]): Header lines for the GDT file.
        info (_GeneDictInfo): Information about the gene dictionary.

    """

    def __init__(
        self,
        initial: Optional[dict[str, GeneUnion]] = None,
        *,
        version: str = "0.0.2",
        header: Optional[list[str]] = None,
        info: Optional[_GeneDictInfo] = None,
    ):
        """Initialize a GeneDict with optional initial data, version, header, and info.

        Args:
            initial (dict): Initial data for the GeneDict.
            version (str): Version of the GDT format. Default is "0.0.2".
            header (list[str]): Header lines for the GDT file.
            info (_GeneDictInfo): Information about the gene dictionary. This normally
                is generated by the `get_info` method, but can be set manually.

        """
        super().__init__(initial or {})
        self.version: str = version
        self.header: list[str] = header or []
        self.info: _GeneDictInfo = info or _GeneDictInfo()

    def to_gdt(
        self: "GeneDict",
        gdt_file: Union[str, Path],
        overwrite: bool = False,
    ) -> None:
        """Write a gene dictionary to a GDT file, sorted by label.

        Args:
            gdt_file (str): Path to the GDT file.
            overwrite (bool): Whether to overwrite the GDT file if it already exists.
                Default is False.

        """
        gdt_file = Path(gdt_file).resolve() if isinstance(gdt_file, str) else gdt_file

        if gdt_file.exists() and not overwrite:
            raise FileExistsError(
                f"GDT file already exists: {gdt_file}. Use overwrite=True to overwrite."
            )

        if self.version != "0.0.2":
            raise ValueError(f"GDT not on version 0.0.2. GDT version: {self.version}")

        all_labels: list[str] = natural_sort(
            {gene.label for gene in self.data.values()}
        )

        label_as_key = defaultdict(list)
        for key, value in self.data.items():
            label_as_key[value.label].append((key, value))

        all_sorted: dict[str, SortedGeneGroups] = {}
        for label, values in label_as_key.items():
            gd: gdList = []
            gn: gnList = []
            dx: dxList = []
            for key, value in values:
                match value:
                    case GeneDescription():
                        gd.append((key, value))
                    case GeneGeneric():
                        gn.append((key, value))
                    case DbxrefGeneID():
                        dx.append((key, value))

            # Sort each group once
            all_sorted[label] = (
                natural_sort(gd, key=lambda x: x[0]),
                natural_sort(gn, key=lambda x: x[0]),
                natural_sort(dx, key=lambda x: x[0]),
            )

        with open(gdt_file, "w") as f:
            for line in self.header:
                f.write(f"#! {line}\n")

            for label in all_labels:
                f.write(f"\n[{label}]\n")
                gd, gn, dx = all_sorted[label]

                for key, value in gd:
                    f.write(
                        f"{key} #gd {value.source}"
                        f"{' #c ' + value.c if value.c else ''}\n"
                    )

                for key, value in gn:
                    if value.an_sources:
                        f.write(
                            f"{key} #gn {' '.join(value.an_sources)}"
                            f"{' #c ' + value.c if value.c else ''}\n"
                        )
                    else:
                        f.write(f"{key} #gn{' #c ' + value.c if value.c else ''}\n")

                for key, value in dx:
                    f.write(
                        f"{key} #dx {value.an_source}:{value.GeneID}"
                        f"{' #c ' + value.c if value.c else ''}\n"
                    )

    def get_info(
        self: "GeneDict",
    ) -> None:
        """Get information about the gene dictionary.

        This method populates the `info` attribute with the number of unique labels,
        total entries, and counts of each type of gene entry.

        `info` attribute is an instance of `_GeneDictInfo` with the following fields:
            - labels: Number of unique labels in the dictionary.
            - total_entries: Total number of entries in the dictionary.
            - gene_descriptions: Count of `GeneDescription` entries.
            - gene_generics: Count of `GeneGeneric` entries.
            - dbxref_GeneIDs: Count of `DbxrefGeneID` entries.

        """
        info = _GeneDictInfo()
        labels = set()
        gd_int = 0
        gn_int = 0
        dx_int = 0

        for key in self.data:
            labels.add(self.data[key].label)
            match self.data[key]:
                case DbxrefGeneID():
                    dx_int += 1
                case GeneGeneric():
                    gn_int += 1
                case GeneDescription():
                    gd_int += 1
                case _:
                    print(f"[INFO] Unknown type for key {key}: {type(self.data[key])}")

        info.labels = len(labels)
        info.total_entries = len(self.data)
        info.gene_descriptions = gd_int
        info.gene_generics = gn_int
        info.dbxref_GeneIDs = dx_int
        self.info = info

    def __repr__(self) -> str:
        """Return a string representation of the GeneDict."""
        return (
            f"GeneDict(version={self.version}, header={self.header}, info={self.info})"
        )

    def __str__(self) -> str:
        """Return a string representation of the GeneDict."""
        return (
            f"GeneDict(version={self.version}, header={self.header}, info:{self.info})"
        )


T = TypeVar("T")
G = TypeVar("G", bound=_Gene)

GeneTuple = tuple[str, GeneUnion]
GeneList = list[tuple[str, G]]

gdList = GeneList[GeneDescription]
gnList = GeneList[GeneGeneric]
dxList = GeneList[DbxrefGeneID]

SortedGeneGroups = tuple[gdList, gnList, dxList]


def read_gdt(
    gdt_file: Union[str, Path],
    max_an_sources: int = 0,
) -> GeneDict:
    """Read a gdt file into GeneDict.

    Args:
        gdt_file (str): Path to the GDT file.
        max_an_sources (int): Maximum number of AN sources to include in GeneGeneric.
                            If set to 0, all sources will be included. Default is 0.

    Returns:
        GeneDict: A dictionary containing the gdt file information.

    """
    gdt_file = Path(gdt_file).resolve()

    if not gdt_file.exists():
        raise FileNotFoundError(f"GDT file not found: {gdt_file}")

    with open(gdt_file, "r") as f:
        lines = [line.strip() for line in f.read().split("\n") if line.strip()]

    if lines[0] != "#! version 0.0.2":
        raise ValueError(
            f"Invalid GDT file version: {lines[0]}. Expected '#! version 0.0.2'"
        )

    result = GeneDict()
    for line in lines:
        if line.startswith("#!"):
            result.header.append(line[2:].strip())
            continue
        else:
            break

    current_section = None
    for line in lines:
        if line.startswith("[") and line.endswith("]"):
            current_section = line[1:-1]
            continue

        # Skip if no section is defined
        if not line or not current_section:
            continue

        # Parse gene line
        tag = line.split("#", 1)[0].strip()
        if not tag:
            print(f"Skipping empty tag in line: {line}")
            continue

        if "#c" in line:
            line, comment = line.split("#c", 1)
            comment = comment.strip()
            line = line.strip()
        else:
            comment = None

        if "#dx" in line:  # DbxrefGeneID dx
            stuff = line.split("#dx", 1)[1].strip()
            an_source = stuff.split(":")[0].strip()
            dbxref = int(stuff.split(":")[1].strip())

            result[tag] = DbxrefGeneID(
                label=current_section, an_source=an_source, GeneID=dbxref, c=comment
            )

        elif "#gn" in line:  # GeneGeneric gn
            an_sources = [s.strip() for s in line.split("#gn", 1)[1].strip().split()]
            an_sources = an_sources if an_sources else []

            if len(an_sources) >= max_an_sources and max_an_sources > 0:
                an_sources = an_sources[:max_an_sources]
                comment = comment if comment else ""
                comment += f" |More than {max_an_sources} sources,"
                f"adding only the first {max_an_sources}|"

            result[tag] = GeneGeneric(
                label=current_section, an_sources=an_sources, c=comment
            )

        elif "#gd" in line:  # GeneDescription gd
            source = line.split("#gd", 1)[1].strip()

            result[tag] = GeneDescription(
                label=current_section, source=source, c=comment
            )

    result.get_info()
    return result


def _natural_sort_key(s: str) -> list[Union[int, str]]:
    return [int(c) if c.isdigit() else c.lower() for c in re.split(r"(\d+)", s)]


def natural_sort(
    iterable: Iterable[T],
    key: Callable[[T], str] | None = None,
    reverse: bool = False,
) -> list[T]:
    """Sort a list in natural order.

    Args:
        iterable: An iterable to sort.
        key: Function to extract comparison key from each element.
        reverse: Whether to sort in reverse order.

    Returns:
        A sorted list in natural order.

    """
    if key is None:  # Original behavior for simple strings
        # Type narrowing: if key is None, T must be str
        return sorted(iterable, key=_natural_sort_key, reverse=reverse)  # type: ignore[arg-type]

    return sorted(iterable, key=lambda x: _natural_sort_key(key(x)), reverse=reverse)


def create_stripped_gdt(
    log: Optional[logger_setup.GDTLogger],
    gdt_file: Union[Path, str],
    gdt_file_out: Union[Path, str],
    overwrite: bool = True,
) -> None:
    """Create a stripped GDT file containing only GeneDescription entries.

    Args:
        log (logger_setup.GDTLogger): Logger instance for logging.
        gdt_file (Union[Path, str]): Path to the input GDT file.
        gdt_file_out (Union[Path, str]): Path to the output GDT file.
        overwrite (bool): Whether to overwrite the output GDT file if it exists.
            Default is True.

    """
    gdt_file = Path(gdt_file).resolve()
    gdt_file_out = Path(gdt_file_out).resolve()

    log = log or logger_setup.create_simple_logger(
        print_to_console=False,
        save_to_file=False,
    )

    if not gdt_file.exists():
        log.error(f"gdt not found: {gdt_file}")
        raise FileNotFoundError(f"GDT file not found: {gdt_file}")

    if gdt_file_out.exists() and not overwrite:
        log.error(f"gdt already exists, overwrite: {overwrite} | gdt: {gdt_file_out}")
        raise FileExistsError(
            f"GDT file already exists: {gdt_file_out}. Use overwrite=True to overwrite."
        )

    gene_dict = read_gdt(gdt_file)
    header = gene_dict.header
    header.append(
        f"{datetime.now().strftime('%Y-%m-%d %H:%M')}"
        f" - Stripped GDT version from original GDT file {gdt_file.name}"
    )

    # keep only GeneDescription
    stripped = GeneDict()
    stripped.data = {
        key: value
        for key, value in gene_dict.items()
        if isinstance(value, GeneDescription)
    }

    stripped.get_info()
    stripped.header = header
    stripped.to_gdt(gdt_file_out, overwrite=overwrite)

    log.info("Info before stripping:")
    logger_setup.log_gdt_info(log, gene_dict)

    log.info("\nNew Header:")
    for txt in stripped.header:
        log.info(txt)

    log.info("New Info:")
    logger_setup.log_gdt_info(log, stripped)


def create_empty_gdt(gdt_file: Union[Path, str]) -> None:
    """Create an empty GDT file.

    Args:
        gdt_file (str): Path to the GDT file.

    """
    gdt_file = Path(gdt_file).resolve()

    with open(gdt_file, "w") as f:
        f.write("#! version 0.0.2\n")
        f.write(f"#! {datetime.now().strftime('%Y-%m-%d %H:%M')} - Empty gdt_file\n")

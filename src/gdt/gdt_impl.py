# -*- coding: utf-8 -*-
"""GDT implementation for handling gene nomenclature data.

This module provides classes and functions to read, write, and manipulate gene
nomenclature data in GDT (Gene Description Table) format. It includes the
`GeneDict` class for storing gene information, as well as utility functions for
reading GDT files, sorting gene entries, and creating stripped GDT files.

"""

import re
from collections import UserDict, defaultdict
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Callable, Iterable, Mapping, Optional, TypeVar, Union

__gdt_version__ = "0.0.2"


@dataclass(slots=True)
class _Gene:
    label: str
    c: Optional[str]


@dataclass(slots=True)
class DbxrefGeneID(_Gene):
    """A gene with a Dbxref GeneID."""

    an_source: str
    GeneID: int


@dataclass(slots=True)
class GeneGeneric(_Gene):
    """A generic gene ID with multiple AN sources."""

    an_sources: list[str] = field(default_factory=list)


@dataclass(slots=True)
class GeneDescription(_Gene):
    """A description of a gene."""

    source: str


@dataclass(slots=True)
class GeneDictInfo:
    """Information about the gene dictionary.

    Attributes:
        labels (int): Number of unique labels in the dictionary.
        total_entries (int): Total number of entries in the dictionary.
        gene_descriptions (int): Count of `GeneDescription` entries.
        gene_generics (int): Count of `GeneGeneric` entries.
        dbxref_GeneIDs (int): Count of `DbxrefGeneID` entries.

    """

    labels: int = 0
    total_entries: int = 0
    gene_descriptions: int = 0
    gene_generics: int = 0
    dbxref_GeneIDs: int = 0


GeneUnion = Union[GeneDescription, GeneGeneric, DbxrefGeneID]


class GeneDict(UserDict[str, GeneUnion]):
    """A dictionary to store gene nomeclature information with additional metadata.

    Attributes:
        version (str): Version of the GDT format.
        header (list[str]): Header lines for the GDT file.
        info (GeneDictInfo): Information about the gene dictionary.

    """

    def __init__(
        self,
        initial: Optional[Mapping[str, GeneUnion]] = None,
        *,
        version: str = __gdt_version__,
        header: Optional[list[str]] = None,
        info: Optional[GeneDictInfo] = None,
        lazy_info: bool = True,
    ):
        """Initialize a GeneDict with optional initial data, version, header, and info.

        Args:
            initial (dict): Initial data for the GeneDict.
            version (str): Version of the GDT format. Default is __gdt_version__.
            header (list[str]): Header lines for the GDT file.
            info (GeneDictInfo): Information about the gene dictionary. This normally
                                 is generated by the `update_info` method,
                                 but can be set manually.
            lazy_info (bool): If False, `update_info` will be called at initialization.
                              Default is True, meaning the info will not be updated
                              until `update_info` is called.

        """
        super().__init__(initial or {})
        self.version: str = version
        self.header: list[str] = header or []
        self.info: GeneDictInfo = info or GeneDictInfo()

        if not lazy_info:
            self.update_info()

    def to_gdt(
        self,
        gdt_file: Union[str, Path],
        overwrite: bool = False,
    ) -> None:
        """Write a gene dictionary to a GDT file, sorted by label.

        Args:
            gdt_file (str): Path to the GDT file.
            overwrite (bool): Whether to overwrite the GDT file if it already exists.
                Default is False.

        """
        gdt_file = Path(gdt_file).resolve()

        if gdt_file.exists() and not overwrite:
            raise FileExistsError(
                f"GDT file already exists: {gdt_file}. Use overwrite=True to overwrite."
            )

        if self.version != __gdt_version__:
            raise ValueError(
                f"GDT not on version {__gdt_version__}. GDT version: {self.version}"
            )

        all_labels: list[str] = natural_sort(
            {gene.label for gene in self.data.values()}
        )

        label_as_key = defaultdict(list)
        for key, value in self.data.items():
            label_as_key[value.label].append((key, value))

        all_sorted: dict[str, SortedGeneGroups] = {}
        for label, values in label_as_key.items():
            gd: gdList = []
            gn: gnList = []
            dx: dxList = []
            for key, value in values:
                match value:
                    case GeneDescription():
                        gd.append((key, value))
                    case GeneGeneric():
                        gn.append((key, value))
                    case DbxrefGeneID():
                        dx.append((key, value))

            # Sort each group once
            all_sorted[label] = (
                natural_sort(gd, key=lambda x: x[0]),
                natural_sort(gn, key=lambda x: x[0]),
                natural_sort(dx, key=lambda x: x[0]),
            )

        with open(gdt_file, "w") as f:
            for line in self.header:
                f.write(f"#! {line}\n")

            for label in all_labels:
                f.write(f"\n[{label}]\n")
                gd, gn, dx = all_sorted[label]

                for key, value in gd:
                    f.write(
                        f"{key} #gd {value.source}"
                        f"{' #c ' + value.c if value.c else ''}\n"
                    )

                for key, value in gn:
                    if value.an_sources:
                        f.write(
                            f"{key} #gn {' '.join(value.an_sources)}"
                            f"{' #c ' + value.c if value.c else ''}\n"
                        )
                    else:
                        f.write(f"{key} #gn{' #c ' + value.c if value.c else ''}\n")

                for key, value in dx:
                    f.write(
                        f"{key} #dx {value.an_source}:{value.GeneID}"
                        f"{' #c ' + value.c if value.c else ''}\n"
                    )

    def update_info(self) -> None:
        """Update the information about the gene dictionary.

        This method populates the `info` attribute with the number of unique labels,
        total entries, and counts of each type of gene entry.

        `info` attribute is an instance of `GeneDictInfo` with the following fields:
            - labels: Number of unique labels in the dictionary.
            - total_entries: Total number of entries in the dictionary.
            - gene_descriptions: Count of `GeneDescription` entries.
            - gene_generics: Count of `GeneGeneric` entries.
            - dbxref_GeneIDs: Count of `DbxrefGeneID` entries.

        """
        self.info = GeneDictInfo()  # Reset info
        labels = set()

        for value in self.data.values():
            labels.add(value.label)
            match value:
                case DbxrefGeneID():
                    self.info.dbxref_GeneIDs += 1

                case GeneGeneric():
                    self.info.gene_generics += 1

                case GeneDescription():
                    self.info.gene_descriptions += 1

                case _:
                    print(f"[INFO] Unknown type for {value}")

        self.info.labels = len(labels)
        self.info.total_entries = len(self.data)

    def create_stripped(self, lazy_info: bool = True) -> "GeneDict":
        """Create a stripped version of the GeneDict.

        This method removes all entries that are not instances of `GeneDescription`
        and updates the header to indicate that the GDT version has been stripped.

        Args:
            lazy_info (bool): If False, `update_info` will be called on the stripped
                              GeneDict. Default is True, meaning the info will not
                              be updated until `update_info` is called.

        Returns:
            GeneDict: A new GeneDict instance with only `GeneDescription` entries
                      and an updated header.

        """
        header = self.header.copy()
        header.append(f"{time_now()} - Stripped GDT version from original GDT file")

        stripped_data = {
            key: value
            for key, value in self.data.items()
            if isinstance(value, GeneDescription)
        }

        return GeneDict(
            initial=stripped_data,
            version=self.version,
            header=header,
            lazy_info=lazy_info,
        )

    def __repr__(self) -> str:
        """Return a string representation of the GeneDict."""
        return (
            f"GeneDict(version={self.version}, header={self.header}, info={self.info})"
        )

    def __str__(self) -> str:
        """Return a string representation of the GeneDict."""
        return (
            f"GeneDict(version={self.version}, header={self.header}, info:{self.info})"
        )


def time_now() -> str:
    """Return the current time formatted as a string."""
    return datetime.now().strftime("%Y-%m-%d %H:%M")


T = TypeVar("T")
G = TypeVar("G", bound=_Gene)

GeneList = list[tuple[str, G]]

gdList = GeneList[GeneDescription]
gnList = GeneList[GeneGeneric]
dxList = GeneList[DbxrefGeneID]

SortedGeneGroups = tuple[gdList, gnList, dxList]


def read_gdt(
    gdt_file: Union[str, Path],
    max_an_sources: int = 0,
) -> GeneDict:
    """Read a gdt file into GeneDict.

    Args:
        gdt_file (str): Path to the GDT file.
        max_an_sources (int): Maximum number of AN sources to include in GeneGeneric.
                            If set to 0, all sources will be included. Default is 0.

    Returns:
        GeneDict: A dictionary containing the gdt file information.

    """
    gdt_file = Path(gdt_file).resolve()

    if not gdt_file.exists():
        raise FileNotFoundError(f"GDT file not found: {gdt_file}")

    with open(gdt_file, "r") as f:
        lines = [line.strip() for line in f.read().split("\n") if line.strip()]

    if lines[0] != "#! version 0.0.2":
        raise ValueError(
            f"Invalid GDT file version: {lines[0]}. Expected '#! version 0.0.2'"
        )

    result = GeneDict()
    for line in lines:
        if line.startswith("#!"):
            result.header.append(line[2:].strip())
            continue
        else:
            break

    current_section = None
    for line in lines:
        if line.startswith("[") and line.endswith("]"):
            current_section = line[1:-1]
            continue

        # Skip if no section is defined
        if not line or not current_section:
            continue

        # Parse gene line
        tag = line.split("#", 1)[0].strip()
        if not tag:
            print(f"Skipping empty tag in line: {line}")
            continue

        if "#c" in line:
            line, comment = line.split("#c", 1)
            comment = comment.strip()
            line = line.strip()
        else:
            comment = None

        if "#dx" in line:  # DbxrefGeneID dx
            stuff = line.split("#dx", 1)[1].strip()
            an_source = stuff.split(":")[0].strip()
            dbxref = int(stuff.split(":")[1].strip())

            result[tag] = DbxrefGeneID(
                label=current_section,
                an_source=an_source,
                GeneID=dbxref,
                c=comment,
            )

        elif "#gn" in line:  # GeneGeneric gn
            an_sources = [s.strip() for s in line.split("#gn", 1)[1].strip().split()]
            an_sources = an_sources if an_sources else []

            if len(an_sources) >= max_an_sources and max_an_sources > 0:
                an_sources = an_sources[:max_an_sources]
                comment = comment if comment else ""
                comment += f" |More than {max_an_sources} sources,"
                f"adding only the first {max_an_sources}|"

            result[tag] = GeneGeneric(
                label=current_section,
                an_sources=an_sources,
                c=comment,
            )

        elif "#gd" in line:  # GeneDescription gd
            source = line.split("#gd", 1)[1].strip()

            result[tag] = GeneDescription(
                label=current_section,
                source=source,
                c=comment,
            )

    result.update_info()
    return result


def natural_sort_key(s: str) -> list[Union[int, str]]:
    """Generate a natural sort key for a string.

    This function splits the string into parts of digits and non-digits,
    converting digit parts to integers and leaving non-digit parts as strings.

    Args:
        s (str): The string to generate a natural sort key for.

    Returns:
        list[Union[int, str]]: A list where digit parts are converted to integers
                               and non-digit parts are converted to lowercase strings.

    """
    return [int(c) if c.isdigit() else c.lower() for c in re.split(r"(\d+)", s)]


def natural_sort(
    iterable: Iterable[T],
    key: Callable[[T], str] | None = None,
    reverse: bool = False,
) -> list[T]:
    """Sort a list in natural order.

    This function sorts an iterable in natural order, which means that it sorts
    strings in a way that is intuitive to humans, taking into account numeric
    values within the strings. If a key function is provided, it will be used
    to extract the comparison key from each element before sorting.
    If the key is None, it will sort the strings directly using the natural sort key.

    Args:
        iterable: An iterable to sort.
        key: Function to extract comparison key from each element.
        reverse: Whether to sort in reverse order.

    Returns:
        A sorted list in natural order.

    """
    if key is None:  # Original behavior for simple strings
        # Type narrowing: if key is None, T must be str
        return sorted(iterable, key=natural_sort_key, reverse=reverse)  # type: ignore[arg-type]

    return sorted(iterable, key=lambda x: natural_sort_key(key(x)), reverse=reverse)


def create_empty_gdt(
    gdt_file: Union[Path, str],
    default_text: str = "Empty gdt_file",
    overwrite: bool = False,
) -> None:
    """Create an empty GDT file.

    This function creates an empty GDT file with a default header and a timestamp.

    Args:
        gdt_file (Union[Path, str]): Path to the GDT file to create.
        default_text (str): Default text to include in the header.
                            Default is 'Empty gdt_file'.
        overwrite (bool): Whether to overwrite the file if it already exists.
                          Default is False.

    """
    gdt_file = Path(gdt_file).resolve()

    if not overwrite and gdt_file.exists():
        raise FileExistsError(
            f"GDT file already exists: {gdt_file}. Use overwrite=True to overwrite."
        )

    with open(gdt_file, "w") as f:
        f.write(f"#! version {__gdt_version__}\n")
        f.write(f"#! {time_now()} - {default_text}\n")
